---
theme: sirius-college
exportFilename: final/dsa_lection_2
layout: cover
---

# Основы алгоритмизации и программирования<br>Лекция 2. Числовые алгоритмы

Арифметика по модулю: сложение, умножение,
возведение в степень, алгоритм Евклида, расширенный
алгоритм Евклида, деление. Проверка чисел на простоту.
Генерация случайных простых чисел. Криптография:
схемы с закрытым ключом, RSA.

---
layout: section
---

# Арифметика по модулюю: сложение, умножение, возведение в степень, алгоритм Евклида, расширенный алгоритм Евклида, деление

---

# Необходимость использования

1. Ограничения на объем типов данных
2. Время выполнения операций на больших числах
3. Использование встроенных функций ограниченно типами данных и особенностями реализации

---

# Основные идеи

Использование массивов, состоящих из чисел “коротких” (играют роль цифр)
и число `st`, означающее позиции с которой начинаются отличные от нуля
цифры.

Зададим максимальную длину длинного числа `MAXLEN`

Зададим основание “системы счисления” `SYS`

::center
![alt text](/img/2/image.png)
::

---

# Сложение больших чисел

```python {*}{maxHeight:'420px'}
def add(a, st_a, b, st_b):
    res = [0] * MAXLEN
    flag = 0
    mxop = a if st_a > st_b else b
    mnop = a if st_a <= st_b else b

    st_min = min(st_a, st_b)
    st_max = max(st_a, st_b)
    st = st_min

    for i in range(MAXLEN-1, st_max - 1, -1):
        res[i] = mxop[i] + mnop[i] + flag
        flag = res[i] // SYS
        res[i] %= SYS

    for i in range(st_max - 1, st_min - 1, -1):
        res[i] = mnop[i] + flag
        flag = res[i] // SYS
        res[i] %= SYS

    if flag:
        res[st-1] = flag

    return res, st
```

---

# Умножение больших чисел на малые

```python {*}{maxHeight:'420px'}
def mul(a, st, b, offs):
    res = [0 for i in range(MAXLEN)]
    flag = 0

    for i in range(MAXLEN - offs, MAXLEN):
        print(i)
        res[i] = 0

    for i in range(MAXLEN-1, st-1, -1):
        res[i-offs] = a[i] * b + flag
        flag = res[i-offs] // SYS
        res[i-offs] %= SYS

    if flag:
        res[st-offs-1] = flag
    st -= offs

    return res, st
```

---

# Умножение больших чисел

```python {*}{maxHeight:'420px'}
def mul_long(a, st_a, b, st_b):
    res = [0 for i in range(MAXLEN)]
    st = MAXLEN-1
    for i in range(MAXLEN-1, st_a-1, -1):
        temp, st_temp = mul(b, st_b, a[i], MAXLEN-1-i)
        res, st = add(res, st, temp, st_temp)

    return res, st
```

---

# Возведение в степень

Наивный алгоритм имеет сложность $O(N)$, где $N$ - степень.

Помня о том, что при возведении числа в степени в какую-либо степень показатели степеней перемножаются. Отсюда следует, что возможно сократить четные степени. Например:

$3^4=(3 \cdot 3 \cdot 3 \cdot 3)$ - 3 операции умножения

${3^2}^2 = (3 \cdot 3)^2$ - 2 операции умножения

---

# Возведение в степень

```python {*}{maxHeight:'420px'}
def power(a, n):
    k = n
    b = 1
    c = a
    while k > 0:
        if k % 2 == 0:
            k /= 2
            c *= c
        else:
            k -= 1
            b *= c
    return b
```

::v-click

> Сложность: $O(log(N))$

::

---
layout: statement
---

Если два целых числа $a$ и $b$ при делении на $m$ дают одинаковые остатки, то они называются сравнимыми (или равноостаточными) по модулю числа $m$.

$$
a \equiv b \pmod{m}
$$

---

# Сравнение по модулю

Определение сравнимости чисел $a$ и $b$ по модулю $m$ равносильно любому из следующих утверждений:

- разность чисел $a$ и $b$ делится на $m$ без остатка;
- число $a$ может быть представлено в виде $a=b+k \cdot m$, где $k$ — некоторое целое число.

---

# Операции по модулю

$$
(A + B)\pmod{C} = (A \pmod{C} + B \pmod{C}) \pmod{C} \\
(A \cdot B) \pmod{C} = (A \pmod{C} * B \pmod{C}) \pmod{C} \\
A^B \pmod{C} = ( (A \pmod{C})^B ) \pmod{C}
$$

<!--
A=14, B=17, C=5
1. Давайте проверим: (A + B) mod C = (A mod C + B mod C) mod C
1. ЛЧ = левая часть равенства
1. ПЧ = правая часть равенства
1. ЛЧ = (A + B) mod C
1. ЛЧ = (14 + 17) mod 5
1. ЛЧ = 31 mod 5
1. ЛЧ = 1
1. ПЧ = (A mod C + B mod C) mod C
1. ПЧ = (14 mod 5 + 17 mod 5) mod 5
1. ПЧ = (4 + 2) mod 5
1. ПЧ = 1
1. ЛЧ = ПЧ = 1
-->

---

# Обратное число по модулю

Числом, обратным к числу A, называется такое число $1/A$, что $A * 1/A = 1$ (то есть, к примеру, для числа $5$ обратным будет $1/5$).

У каждого вещественного числа, кроме $0$, есть обратное.

Умножение на число, обратное A, эквивалентно делению на A (то есть, к примеру, $10/5$ — это то же, что $10 * 1/5$).

Число, обратное $A (mod C)$, обозначается $A^-1$.

$(A * A^-1) ≡ 1 (mod C)$ , или, что то же самое, $(A * A^-1) mod C = 1$.

Только у чисел, взаимно простых с $C$ (то есть у тех, у которых нет с C общих
простых делителей), есть обратные $(mod C)$

---

# Нахождение обратного числа по модулю

Вычисляем $A * B mod C$ для всех $B$ от $0$ до $C-1$.

Обратным числом для $A mod C$ будет являться такое $B$, для которого $A * B
mod C = 1$

Обратите внимание, что $B mod C$ может принимать значения от $0$ до $C-1$,
поэтому нет смысла проверять числа, большие чем B.

---

# НОД и НОК

Любое число можно представить в виде одномерного массива, содержащего
простые числа, и еще одного одномерного массива для непосредственного
представления числа, в каждой ячейке которого содержится степень
соответствующего простого числа.

Например, массив простых чисел $[2, 3, 5, 7, 11, 13]$, тогда массив с
представлением числа $2600$ будет выглядеть как $[3, 0, 2, 0, 0, 1]$ из
которого можно получить $(2^3) * (5 ^ 2) * (13 ^ 1) = 2600$.

---

# НОД и НОК

Простая реализация умножения: достаточно сложить соответствующие
элементы массивов.

Для нахождения НОД достаточно выбрать минимум из степеней.

Для нахождения НОК достаточно выбрать максимум из степеней.

---

# Алгоритм Евклида

Даны два целых положительных числа $m$ и $n$. Требуется найти их
наибольший общий делитель, т. е. наибольшее целое положительное число,
которое нацело делит оба числа $m$ и $n$.

1. [Нахождение остатка.] Разделим $m$ на $n$, и пусть остаток от деления
   будет равен $r$ (где $0 ≤ r < n$).
2. [Сравнение с нулем.] Если $r = 0$, то выполнение алгоритма
   прекращается; $n$ — искомое значение.
3. [Замещение.] Присвоить $m ← n, n ← r$ и вернуться к шагу **1**.

---

# Проверка числа на простоту

Необходимо узнать, существуют ли такие натуральные числа $x, y$ ($1 < x, y < 
N$), что $x*y = N$.

Условимся, что $x \le y$, тогда можно сказать, что $x$ меньше либо равен
квадратному корню из числа $N$.

---

# Проверка числа на простоту

```python
def isPrime(n):
    if n == 2:
        return True
    j = int(n ** 0.5) + 1
    for i in range(2, j + 1):
        if n % i == 0:
            return False
    return True
```

---

# Решето Эратосфена

**Решето Эратосфена** — алгоритм нахождения всех простых чисел, не
превышающих некоторое натуральное число $n$.

1. Выписать подряд все целые числа от двух до $n$ ($2, 3, 4, ..., n$).
2. Пусть переменная $p$ изначально равна двум — первому простому числу.
3. Зачеркнуть в списке числа от $2p$ до $n$, считая шагами по $p$ (это будут
   числа, кратные $p: 2p, 3p, 4p, ...$).
4. Найти первое незачёркнутое число в списке, большее чем $p$, и присвоить
   значению переменной $p$ это число.
5. Повторять шаги **3** и **4**, пока возможно.

---
layout: section
---

# Криптография: схемы с закрытым ключом, RSA.

---

# RSA

**RSA** (аббревиатура от фамилий Rivest, Shamir и Adleman) — криптографический алгоритм с открытым ключом, основывающийся на вычислительной сложности задачи факторизации больших полупростых чисел.

Например, $592939 * 592967 = 351593260013$. Но как имея только число $351593260013$ узнать числа $592939$ и $592967$? Это называется «сложность задачи факторизации произведения двух больших простых чисел», т.е. в одну сторону просто, а в обратную невероятно сложно.

Используется при обмене данными и в качестве цифровой подписи. Является базовой частью протокола HTTPS.

---

# Процедура создания ключей

1. Выбираем два случайных простых числа $p$ и $q$
2. Вычисляем их произведение: $N = p * q$
3. Вычисляем функцию Эйлера: $𝜑(N) = (p-1) * (q-1)$
4. Выбираем число $e$ (обычно простое, но необязательно), которое меньше
   $𝜑(N)$ и является взаимно простым с $𝜑(N)$ (не имеющих общих делителей
   друг с другом, кроме 1).
5. Ищем число $d$, обратное числу $e$ по модулю $𝜑(N)$. Т.е. остаток от деления
   $(d*e)$ и $𝜑(N)$ должен быть равен 1. Найти его можно через расширенный
   алгоритм Евклида.

$e$ и $n$ – открытый ключ
$d$ и $n$ – закрытый ключ

---

# Пример генерации ключей

Пусть $p = 19, q = 41$

$$
N=p • q=779 \\
𝜑(N)=(p - 1) • (q - 1)=720 \\
e=691 \\
d=571
$$

Получается:
${691, 779}$ – открытый ключ
${571, 779}$ – закрытый ключ
