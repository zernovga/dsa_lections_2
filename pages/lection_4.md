---
theme: sirius-college
exportFilename: final/dsa_lection_4
mdc: true
layout: cover
---

# Основы алгоритмизации и программирования<br>Лекция 4. Динамическое программирование

Задача «Калькулятор»: ленивое ДП и ДП назад. Общие принципы динамического программирования. Восстановление ответа. Наибольшая возрастающая подпоследовательность. Дискретная задача о рюкзаке. Редакционное расстояние.

---

# Динамическое программирование

Словосочетание «динамическое программирование» впервые было использовано в 1940-х годах Ричардом Беллманом для описания процесса нахождения решения задачи, где ответ на одну задачу может быть получен только после решения задачи, «предшествующей» ей.

Первоначально эта область была основана, как системный анализ и инжиниринг.

Слово «программирование» в словосочетании «динамическое программирование» в действительности к «традиционному» программированию (написанию кода) почти никакого отношения не имеет и имеет смысл как в словосочетании «математическое программирование», которое является синонимом слова «оптимизация». Поэтому слово «программа» в данном контексте скорее означает оптимальную последовательность действий для получения решения задачи.

---

# Динамическое программирование

**Динамическое программирование** — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

---
layout: statement
---

# **Динамическое программирование** — это когда у нас есть задача, которую непонятно как решать, и мы разбиваем ее на меньшие задачи, которые тоже непонятно как решать.

---

# Задача «Калькулятор»

Дан набор чисел и набор операций над ними. Необходимо найти минимальное количество операций, которое необходимо сделать, чтобы получить из одного числа другое.

Операции:

- умножение на 2
- умножение на 3
- прибавление 1

---

# Задача «Калькулятор»

Пусть $n$ — число, которое нужно получить, а $m$ — число, с которого мы начинаем. Тогда мы можем перейти от $n$ к $m$ двумя способами:

1. Если $n$ делится на 2, то мы можем перейти от $n$ к $n/2$ за один шаг.
2. Если $n$ делится на 3, то мы можем перейти от $n$ к $n/3$ за один шаг.
3. В остальных случаях мы можем перейти от $n$ к $n-1$ за один шаг.

---

# Задача «Калькулятор»

```python
def calculator(n, m):
    if n < m:
        return float('inf')
    if n == m:
        return 0

    op = [1 + calculator(n - 1, m)]
    if n % 3 == 0:
        op.append(1 + calculator(n // 3, m))

    if n % 2 == 0:
        op.append(1 + calculator(n // 2, m))

    return min(op)
```

---

# Принципы ДП

Метод **динамического программирования сверху** (мемоизация, ленивая динамика) — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем.

**Динамическое программирование снизу** (табулация) включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач.

---

# Задача «Калькулятор». ДП сверху

```python
def calculator(n, m, memo={}):
    if n < m:
        return float('inf')
    if n == m:
        return 0

    if n not in memo:
        op = [1 + calculator(n - 1, m, memo)]
        if n % 3 == 0:
            op.append(1 + calculator(n // 3, m, memo))
        if n % 2 == 0:
            op.append(1 + calculator(n // 2, m, memo))
        memo[n] = min(op)

    return memo[n]
```

---

# Задача «Калькулятор». ДП снизу

```python
def calculator(n, m):
    dp = [float('inf')] * (n + 1)
    dp[m] = 0

    for i in range(m, n):
        dp[i + 1] = min(dp[i + 1], dp[i] + 1)
        if i * 2 <= n:
            dp[i * 2] = min(dp[i * 2], dp[i] + 1)
        if i * 3 <= n:
            dp[i * 3] = min(dp[i * 3], dp[i] + 1)

    return dp[n]
```

---
layout: code
---

# Динамическое программирование

Основная идея состоит в том, чтобы:

1. свести задачу для $N$ к задаче для чисел, меньших, чем `N` (с помощью формулы)
2. хранить все ответы в массиве
3. заполнить начало массива вручную (для которых формула не работает)
4. обойти массив и заполнить ответы по формуле
5. вывести ответ откуда-то из этого массива

---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

Рассмотрим последовательность чисел $a_1, a_2, ..., a_n$. Если вычеркнуть из этой последовательности часть чисел, мы получим другую последовательность, которую называют подпоследовательностью данной последовательности.

Рассмотрим теперь еще одну последовательность $b_1, b_2, ..., b_m$. Требуется найти длину самой длинной подпоследовательности последовательности $\{a_i\}$, которая одновременно является и подпоследовательностью последовательности $\{b_j\}$. Такую последовательность называют **наибольшей общей подследовательностью (НОП)**.

<!--
Например,  для последовательностей  1,  2,  3,  4,  5  и  2,  7,  3,  2,  5  НОП  является подпоследовательность 2, 3, 5, состоящая из трёх членов.
-->

---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

Опишем подзадачи, на которые мы будем разбивать нашу задачу. Мы напишем функцию $LCS(p, q)$, которая находит длину НОП для двух начальных участков $a_1, ..., a_p$ и $b_1, ..., b_q$ наших последовательностей. Пусть для всех пар $q$ и $p$ ($p < n, q < m$), мы задачу решать уже научились. Попробуем вычислить LCS(n, m). Рассмотрим два случая:

1. $a_n = b_m$. Тогда $LCS(n, m)=LCS(n-1, m-1)+1$.
2. $a_n ≠ b_m$. Тогда $LCS(n, m)=max(LCS(n, m-1), LCS(n-1, m))$.

Пользуясь этими формулами, мы можем заполнить таблицу значений $LCS(p, q)$ для всех $p$ и $q$ последовательно: сначала заполняем первую строчку слева направо, затем вторую и т.д. Последнее число в последней строке и будет ответом на поставленную задачу.

<!--
Данный алгоритм требует порядка $O(n \cdot m)$ операций.
-->

---
transition: fade
---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

$$
\{a_i\} = [1,  2,  3,  4,  5] \\
\{b_j\} = [2,  7,  3,  2,  5]
$$

---
transition: fade
---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

$$
\{a_i\} = [1, \textcolor{blue}{2},  \textcolor{blue}{3},  4,  \textcolor{blue}{5}] \\
\{b_j\} = [\textcolor{blue}{2},  7,  \textcolor{blue}{3},  2,  \textcolor{blue}{5}] \\
$$

---
transition: fade
---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

$$
\{a_i\} = [1, \textcolor{blue}{2},  \textcolor{blue}{3},  4,  \textcolor{blue}{5}] \\
\{b_j\} = [\textcolor{blue}{2},  7,  \textcolor{blue}{3},  2,  \textcolor{blue}{5}] \\
LCS = [\textcolor{blue}{2},  \textcolor{blue}{3},  \textcolor{blue}{5}]
$$

---
transition: fade
---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

$$
a_n = b_m: LCS(n, m)=LCS(n-1, m-1)+1 \\
a_n ≠ b_m: LCS(n, m)=max(LCS(n, m-1), LCS(n-1, m))
$$

<div style="float:left;width:30%;">

$$
\{a_i\} = [1, \textcolor{blue}{2},  \textcolor{blue}{3},  4,  \textcolor{blue}{5}] \\
\{b_j\} = [\textcolor{blue}{2},  7,  \textcolor{blue}{3},  2,  \textcolor{blue}{5}] \\
LCS = [\textcolor{blue}{2},  \textcolor{blue}{3},  \textcolor{blue}{5}] \\ \\
$$

</div>
<div style="float:right;width:70%;">

<v-switch>

<template #0>

| b\a |  1  |  2  |  3  |  4  |  5  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  2  |     |     |     |     |     |
|  7  |     |     |     |     |     |
|  3  |     |     |     |     |     |
|  2  |     |     |     |     |     |
|  5  |     |     |     |     |     |

</template>

<template #1>

| b\a |  1  |  2  |  3  |  4  |  5  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  2  |  0  |  1  |  1  |  1  |  1  |
|  7  |     |     |     |     |     |
|  3  |     |     |     |     |     |
|  2  |     |     |     |     |     |
|  5  |     |     |     |     |     |

</template>

<template #2>

| b\a |  1  |  2  |  3  |  4  |  5  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  2  |  0  |  1  |  1  |  1  |  1  |
|  7  |  0  |  1  |  1  |  1  |  1  |
|  3  |     |     |     |     |     |
|  2  |     |     |     |     |     |
|  5  |     |     |     |     |     |

</template>

<template #3>

| b\a |  1  |  2  |  3  |  4  |  5  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  2  |  0  |  1  |  1  |  1  |  1  |
|  7  |  0  |  1  |  1  |  1  |  1  |
|  3  |  0  |  1  |  2  |  2  |  2  |
|  2  |     |     |     |     |     |
|  5  |     |     |     |     |     |

</template>

<template #4>

| b\a |  1  |  2  |  3  |  4  |  5  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  2  |  0  |  1  |  1  |  1  |  1  |
|  7  |  0  |  1  |  1  |  1  |  1  |
|  3  |  0  |  1  |  2  |  2  |  2  |
|  2  |  0  |  1  |  2  |  2  |  2  |
|  5  |     |     |     |     |     |

</template>

<template #5-7>

| b\a |  1  |  2  |  3  |  4  |                                5                                |
| :-: | :-: | :-: | :-: | :-: | :-------------------------------------------------------------: |
|  2  |  0  |  1  |  1  |  1  |                                1                                |
|  7  |  0  |  1  |  1  |  1  |                                1                                |
|  3  |  0  |  1  |  2  |  2  |                                2                                |
|  2  |  0  |  1  |  2  |  2  |                                2                                |
|  5  |  0  |  1  |  2  |  2  | <span v-mark="{ at: 6, color: 'red', type: 'circle' }">3</span> |

</template>

</v-switch>

</div>

---

# Наибольшая общая подпоследовательность (НОП, Longest Common Subsequence, LCS)

```python
def lcs(a, b):
    n = len(a)
    m = len(b)
    table = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if a[i - 1] == b[j - 1]:
                table[i][j] = table[i - 1][j - 1] + 1
            else:
                table[i][j] = max(table[i - 1][j],
                                  table[i][j - 1])
    return table[-1][-1]
```

---

# Задача о рюкзаке

**Задача о рюкзаке (Knapsack problem)** — дано $N$ предметов, $n_i$ предмет имеет массу $w_i>0$ и стоимость $p_i>0$. Необходимо выбрать из этих предметов такой набор, чтобы суммарная масса не превосходила заданной величины $W$ (вместимость рюкзака), а суммарная стоимость была максимальна.

Задачу о рюкзаке можно решить несколькими способами:

- Перебирать все подмножества набора из $N$ предметов. Сложность такого решения $O(2^N)$
- Методом Meet-in-the-middle. Сложность решения $O(2^{N/2}N)$
- Метод динамического программирования. Сложность — $O(NW)$

---

# Задача о рюкзаке

Для решения построим таблицу размерности $N$ на $W$, где столбцы соответствуют объему рюкзака, а строки отдельным предметам.

В общем случае формула для стоимости в каждой ячейке выглядит так:

$$
S[i, j] = max (S[i−1, j], p_i + S[i−1, j−w_i]),\\
$$

где $i$ — номер строки, $j$ — столбца.

---
transition: fade
---

# Задача о рюкзаке. Пример

$$
W=13,N=5 \\
w_1=3,p_1=1 \\
w_2=4,p_2=6 \\
w_3=5,p_3=4 \\
w_4=8,p_4=7 \\
w_5=9,p_5=6 \\
$$

---

# Задача о рюкзаке. Пример

<div style="float:left;width:30%;">

$$
W=13,N=5 \\
w_1=3,p_1=1 \\
w_2=4,p_2=6 \\
w_3=5,p_3=4 \\
w_4=8,p_4=7 \\
w_5=9,p_5=6 \\
$$

</div>
<div style="float:right;width:70%;">

<v-switch>

<template #0>

|       |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  |
| ----- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| k = 0 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |

</template>

<template #1>

|       |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  |
| ----- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| k = 0 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| k = 1 |  0  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |

</template>

<template #2>

|       |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  |
| ----- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| k = 0 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| k = 1 |  0  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
| k = 2 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  |  7  |  7  |  7  |  7  |  7  |

</template>

<template #3>

|       |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  |
| ----- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| k = 0 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| k = 1 |  0  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
| k = 2 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  |  7  |  7  |  7  |  7  |  7  |
| k = 3 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  | 10  | 10  | 10  | 11  | 11  |

</template>

<template #4>

|       |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  |
| ----- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| k = 0 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| k = 1 |  0  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
| k = 2 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  |  7  |  7  |  7  |  7  |  7  |
| k = 3 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  | 10  | 10  | 10  | 11  | 11  |
| k = 4 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  | 10  | 10  | 10  | 13  | 13  |

</template>

<template #5>

|       |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  |
| ----- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| k = 0 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| k = 1 |  0  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
| k = 2 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  |  7  |  7  |  7  |  7  |  7  |
| k = 3 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  | 10  | 10  | 10  | 11  | 11  |
| k = 4 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  | 10  | 10  | 10  | 13  | 13  |
| k = 5 |  0  |  0  |  1  |  6  |  6  |  6  |  7  |  7  | 10  | 10  | 10  | 13  | 13  |

</template>

</v-switch>

</div>

---

# Задача о рюкзаке

```python
def knapsack(items, max_weight):
    n = len(items)
    table = [[0] * (max_weight + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, max_weight + 1):
            table[i][j] = max(table[i - 1][j],
                items[i]["price"] + \
                    table[i - 1][j - items[i]["weight"]])

    return table[-1][-1]
```

---

# Задача о рюкзаке

Другие вариации задачи:

- **Ограниченный рюкзак** - каждый предмет может быть выбран ограниченное $b_i$ число раз.
- **Неограниченный рюкзак** - любой предмет может быть выбран любое количество раз.
- **Непрерывный рюкзак** - возможно брать любую дробную часть от предмета, при этом удельная стоимость сохраняется.
- и т.д.

---

# Редакционное расстояние

**Расстояние Левенштейна (редакционное расстояние или дистанция редактирования)** между двумя строками в теории информации и компьютерной лингвистике — это минимальное количество операций вставки одного символа, удаления одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую.

Нахождения расстояния Левенштейна аналогично нахождению НОП для двух строк, за исключением того, что мы ищем не максимальное, а минимальное количество.

---

# Редакционное расстояние

```py {*}{maxHeight: '420px'}
def levenshtein_distance(s1, s2):
    n, m = len(s1), len(s2)

    if n > m:
        s1, s2 = s2, s1
        n, m = m, n

    current_row = range(n + 1)

    for i in range(1, m + 1):
        previous_row, current_row = current_row, [i] + [0] * n
        for j in range(1, n + 1):
            add, delete, change = previous_row[j] + 1, 
                                  current_row[j - 1] + 1, 
                                  previous_row[j - 1]
            if s1[j - 1] != s2[i - 1]:
                change += 1
            current_row[j] = min(add, delete, change)

    return current_row[n]
```
