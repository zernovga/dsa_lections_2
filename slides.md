---
theme: sirius-college
addons:
  - tldraw
---

# Основы алгоритмизации и программирования

---

# Оглавление

1. [Введение](/3)
2. [Числовые алгоритмы](/27)
3. [Алгоритмы сортировки](/51)
4. [Динамическое программирование](/78)
5. [Структуры данных](/104)
6. [Графы](/123)
7. [Кратчайшие пути](/160)

---
src: ./pages/lection_1.md
---

---
src: ./pages/lection_2.md
---

---
theme: sirius-college
exportFilename: final/dsa_lection_3
layout: cover
---

# Основы алгоритмизации и программирования<br>Лекция 3. Алгоритмы сортировки

Квадратичные сортировки (вставками, выбором минимума). Метод «разделяй и властвуй». Бинарный поиск. Сортировка слиянием: наивная и эффективная реализация. Быстрая сортировка: понятие вероятностного алгоритма, время работы в среднем, простейший алгоритм, inplace-алгоритм. IntroSort. Сравнение сортировок.

---
layout: statement
---

# Алгоритм сортировки

это алгоритм для упорядочивания элементов в списке. В случае, когда элемент в списке имеет несколько полей, поле, служащее критерием порядка, называется ключом сортировки.

---

# Постановка задачи

Пусть требуется упорядочить $N$ элементов: $R_1, R_2, \dots, R_n$. Каждый элемент представляет из себя запись $R_j$, содержащую некоторую информацию и ключ $K_j$, управляющий процессом сортировки. На множестве ключей определено отношение порядка $\boldsymbol{<}$ так, чтобы для любых трёх значений ключей $a, b, c$ выполнялись следующие условия:

- закон трихотомии: либо $a<b$, либо $a>b$, либо $a=b$;
- закон транзитивности: если $a<b$ и $b<c$, то $a<c$.

Данные условия определяют математическое понятие линейного или совершенного упорядочения, а удовлетворяющие им множества поддаются сортировке большинством методов.

---
layout: section
---

# Квадратичные сортировки

---

# Сортировка простыми обменами, сортировка пузырьком

Алгоритм состоит из повторяющихся проходов по сортируемому массиву.

За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов.

Проходы по массиву повторяются $N-1$ раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован.

::v-click

> Сложность: $O(n^2)$

::

---

# Сортировка пузырьком

::center

<tldraw class="w-230 h-100" doc="tldraw/bubble.json"></tldraw>

::

---

# Сортировка вставками

В начальный момент отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на нужную позицию в уже отсортированной последовательности до тех пор, пока набор входных данных не будет исчерпан.

Данный алгоритм можно ускорить при помощи использования бинарного поиска для нахождения места текущему элементу в отсортированной части. Проблема с долгим сдвигом массива вправо решается при помощи смены указателей.

::v-click

> Сложность: $O(n^2)$

::

---

# Сортировка вставками

::center

<tldraw class="w-230 h-100" doc="tldraw/insertion.json"></tldraw>

::

---

# Гномья сортировка

**Гномья сортировка** — алгоритм сортировки, похожий на сортировку вставками, но в отличие от последней перед вставкой на нужное место происходит серия обменов, как в сортировке пузырьком. Название происходит от предполагаемого поведения садовых гномов при сортировке линии садовых горшков.

Алгоритм находит первое место, где два соседних элемента стоят в неправильном порядке и меняет их местами. Он пользуется тем фактом, что обмен может породить новую пару, стоящую в неправильном порядке, только до или после переставленных элементов. Он не допускает, что элементы после текущей позиции отсортированы, таким образом, нужно только проверить позицию до переставленных элементов.

::v-click

> Сложность: $O(n^2)$

::

---

# Гномья сортировка

::center

<tldraw class="w-230 h-100" doc="tldraw/gnome.json"></tldraw>

::

---
layout: section
---

# Метод "разделяй и властвуй"

---

# Метод "разделяй и властвуй"

**«Разделяй и властвуй»** в информатике — схема разработки алгоритмов, заключающаяся в рекурсивном разбиении решаемой задачи на две или более подзадачи того же типа, но меньшего размера, и комбинировании их решений для получения ответа к исходной задаче; разбиения выполняются до тех пор, пока все подзадачи не окажутся элементарными.

Применяется в таких алгоритмах как бинарный (двоичный) поиск и сортировка слиянием.

---

# Сортировка слиянием

1.  Сортируемый массив разбивается на две части примерно одинакового размера. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы (любой массив длины 1 можно считать упорядоченным).
2.  Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
3.  Два упорядоченных массива половинного размера соединяются в один.
    1.  На каждом шаге мы берем меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.
    2.  Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.

---

# Сортировка слиянием

```python {*|2|4-9|4|5-6|7-9|10-15|16}{maxHeight: '420px'}
def merge(A, B):
    i, j, C = 0, 0, []
    while True:
        if A[i] < B[j]:
            C.append(A[i])
            i += 1
            if i == len(A):
                C.extend(B[j:])
                break
        else:
            C.append(B[j])
            j += 1
            if j == len(B):
                C.extend(A[i:])
                break
    return C
```

---

# Сортировка слиянием

::center

<tldraw class="w-230 h-100" doc="tldraw/merge.json"></tldraw>

::

---

# Сортировка слиянием

```python
def top_down_merge_sort(A):
    if len(A) == 1:
        return A

    d = len(A) // 2
    left = top_down_merge_sort(A[:d])
    right = top_down_merge_sort(A[d:])

    return merge(left, right)
```

---

# Сортировка слиянием

::center

<tldraw class="w-230 h-100" doc="tldraw/merge_top_down.json"></tldraw>

::

---

# Сортировка слиянием

```python {*}{maxHeight: '420px'}
def bottom_up_merge_sort(A):
    k = 1
    while k < len(A):
        for i in range(0, len(A)-k, 2*k):
            A[i:i+2*k] = merge(A[i:i+k], A[i+k:i+2*k])
        k *= 2

    return A
```

---

# Сортировка слиянием

::center

<tldraw class="w-230 h-100" doc="tldraw/merge_bottom_up.json"></tldraw>

::

---
layout: section
---

# Быстрая сортировка

---

# Быстрая сортировка

**Быстрая сортировка, сортировка Хоара** (quicksort, qsort (по имени в стандартной библиотеке языка Си) — алгоритм сортировки, разработанный английским информатиком Тони Хоаром во время своей работы в МГУ в 1960 году.

Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем $O(n \log{n})$ обменов при упорядочении $n$ элементов.

---

# Быстрая сортировка

1. Массив $a[l…r]$ разбивается на два (возможно пустых) подмассива $a[l…q]$ и $a[q+1…r]$, таких, что каждый элемент $a[l…q]$ меньше или равен $a[q]$, который в свою очередь, не превышает любой элемент подмассива $a[q+1…r]$. Индекс вычисляется в ходе процедуры разбиения.
2. Подмассивы $a[l…q]$ и $a[q+1…r]$ сортируются с помощью рекурсивного вызова процедуры быстрой сортировки.
3. Поскольку подмассивы сортируются на месте, для их объединения не требуются никакие действия: весь массив $a[l…r]$ оказывается отсортированным.

---

# Быстрая сортировка

```python {*|14-19|15|16|1-11|2-3|5-8|5|6|7-8|10|11|16|18-19|*}{maxHeight: '420px'}
def partition(array, low, high):
    pivot = array[high]
    i = low - 1

    for j in range(low, high):
        if array[j] <= pivot:
            i = i + 1
            array[i], array[j] = array[j], array[i]

    array[i + 1], array[high] = array[high], array[i + 1]
    return i + 1


def quicksort(array, low, high):
    if low < high:
        pi = partition(array, low, high)

        quicksort(array, low, pi - 1)
        quicksort(array, pi + 1, high)
```

---

# Быстрая сортировка

::center

<tldraw class="w-230 h-100" doc="tldraw/quicksort.json"></tldraw>

::

---

# IntroSort. Интроспективная сортировка

Алгоритм сортировки, предложенный Дэвидом Мюссером в 1997 году. Он использует быструю сортировку и переключается на пирамидальную сортировку, когда глубина рекурсии превысит некоторый заранее установленный уровень (например, логарифм от числа сортируемых элементов).

---

# Сравнение сортировок

| Сортировка | Время в худшем случае | Время в среднем случае | Затраты памяти в лучшем случае |
| ---------- | :-------------------: | :--------------------: | :----------------------------: |
| Пузырьком  |       $O(n^2)$        |        $O(n^2)$        |             $O(1)$             |
| Вставками  |       $O(n^2)$        |        $O(n^2)$        |             $O(1)$             |
| Гномья     |       $O(n^2)$        |        $O(n^2)$        |             $O(1)$             |
| Слиянием   |    $O(n \log{n})$     |     $O(n \log{n})$     |             $O(n)$             |
| Быстрая    |       $O(n^2)$        |     $O(n \log{n})$     |             $O(1)$             |
| IntroSort  |    $O(n \log{n})$     |     $O(n \log{n})$     |             $O(n)$             |

---


<SlidevGraph
  id="graph1"
  :items="[
    { name: 'foo', color: '#155' },
    { name: 'bar', color: '#551', from: 'foo' },
  ]"
/>

---
src: ./pages/lection_4.md
---

---
src: ./pages/lection_5.md
---

---
src: ./pages/lection_6.md
---

---
src: ./pages/lection_7.md
---